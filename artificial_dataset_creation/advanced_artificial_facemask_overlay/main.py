import os
import numpy as np
import cv2
import dlib
import csv
import argparse

MAIN_DIR = os.getcwd()

MASK_FOLDER = os.path.join(MAIN_DIR, 'mask')
FACE_FOLDER = os.path.join(MAIN_DIR, 'face')
DATASET_FOLDER = os.path.join(MAIN_DIR, 'DATASET')

parser = argparse.ArgumentParser(description='Adds a mask to a given image.')

parser.add_argument('-mp', '--maskfolder', type=str, default=MASK_FOLDER, help="Absolute path to mask folder")
parser.add_argument('-fp', '--facefolder', type=str, default=FACE_FOLDER, help="Absolute path to face folder")
parser.add_argument('-dp', '--datasetfolder', type=str, default=DATASET_FOLDER, help="Absolute path to face folder")
parser.add_argument('-p', '--PATTERN',
                    choices=['cover_both', 'uncover_both', 'uncover_nose', 'slice_face'],
                    type=str, help='Overlay mask with "uncover_nose", "uncover_both" or "cover_both"')

arg = vars(parser.parse_args())

detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")

dst_num = [1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 30, 33,  # 0-12
           50, 49, 48, 54, 53, 52,  # 13-18
           59, 58, 57, 56, 55, 51]  # 19-24

masks = [m for m in os.listdir(arg['maskfolder'])
         if (os.path.isfile(os.path.join(arg['maskfolder'], m)) and (os.path.splitext(os.path.basename(m))[1] == ".png"))]

print("Masks found:")
print(masks)

unmasked_faces = [f for f in os.listdir(arg['facefolder']) if os.path.isfile(os.path.join(arg['facefolder'], f))]
print("Faces found: ")
print(unmasked_faces)


def remove_color(image, target_value):
    for r in range(0, image.shape[0]):
        for c in range(0, image.shape[1]):
            if image[r][c][3] == target_value:
                image[r][c][0:3] = 0., 0., 0.
            else:
                pass


def overlay_mask(dst_face_point_arg, mask_img_path_arg, mask_img_arg, face_img_arg):
    dst_face_point = np.array(dst_face_point_arg, dtype="float32")

    # load mask annotations from csv file to source points
    mask_annotation = os.path.splitext(os.path.basename(mask_img_path_arg))[0]
    mask_annotation = os.path.join(arg['maskfolder'], mask_annotation + ".csv", )

    with open(mask_annotation) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=",")
        src_pts = []
        for i, row in enumerate(csv_reader):
            # skip head or empty line if it's there
            try:
                src_pts.append(np.array([float(row[1]), float(row[2])]))
            except ValueError:
                continue
    src_pts = np.array(src_pts, dtype="float32")

    mask_img = mask_img_arg.astype(np.float32) / 255.0
    face_img = face_img_arg.astype(np.float32) / 255.0

    # get the perspective transformation matrix
    M, _ = cv2.findHomography(src_pts, dst_face_point[0:12])

    # transformed masked image
    transformed_mask = cv2.warpPerspective(mask_img, M, (face_img.shape[1], face_img.shape[0]),
                                           None, cv2.INTER_LINEAR, cv2.BORDER_CONSTANT)

    # reverse transparency
    b, g, r, a = cv2.split(transformed_mask)
    a = 1.0 - a
    transformed_mask = cv2.merge((b, g, r, a))

    # remove redundant color generated by stupid OpenCV
    remove_color(mask_img, 0.)
    remove_color(transformed_mask, 1.0)

    # mask overlay
    alpha_mask = transformed_mask[:, :, 3]
    alpha_image = 1.0 - alpha_mask
    for c in range(0, 3):
        face_img[:, :, c] = (alpha_image * transformed_mask[:, :, c] + alpha_mask * face_img[:, :, c])

    # denormalize the face_img
    face_img = face_img * 255.0

    return face_img


def image_handle(mask_img_path, face_img_path, case):
    face_img = cv2.imread(face_img_path)
    mask_img = cv2.imread(mask_img_path, cv2.IMREAD_UNCHANGED)

    print(face_img_path)
    print(mask_img_path)

    # dst_face_point for storing target points for overlaying mask
    # x_array and y_array for finding edge value (max and min) to slice the final image to face size
    dst_face_point, x_array, y_array = [], [], []
    gray_face = cv2.cvtColor(src=face_img, code=cv2.COLOR_BGR2GRAY)
    faces = detector(gray_face)

    if len(faces) == 0:
        print('No face found')
        return 0
    elif len(faces) > 1:
        print(len(faces), 'Multiple faces found')
        return 0
    else:
        print('Valid image')

    for face in faces:
        print(face)
        landmarks = predictor(image=gray_face, box=face)
        # Loop through all the points
        for n in range(0, 68):
            x = landmarks.part(n).x
            x_array.append(x)
            y = landmarks.part(n).y
            y_array.append(y)

            # Draw circles on face landmark points
            # cv2.circle(img=face_img, center=(x, y), radius=3, color=(0, 255, 0), thickness=-1)

        # Create an array to hold target points
        for i in dst_num:
            dst_face_point.append(np.array([landmarks.part(i).x, landmarks.part(i).y]))

    if case == "uncover_nose":
        uncover_nose(dst_face_point)
        face_img = overlay_mask(dst_face_point, mask_img_path, mask_img, face_img)
    elif case == "uncover_both":
        uncover_both(dst_face_point)
        face_img = overlay_mask(dst_face_point, mask_img_path, mask_img, face_img)
    elif case == "cover_both":
        face_img = overlay_mask(dst_face_point, mask_img_path, mask_img, face_img)
    elif case == "slice_face":
        pass

    face_img_slice = face_img[min(y_array):max(y_array), min(x_array):max(x_array)]

    save_target_path = os.path.join(arg['datasetfolder'], arg['PATTERN'])
    if not os.path.exists(save_target_path):
        os.makedirs(save_target_path)

    cv2.imwrite(os.path.join(save_target_path, os.path.splitext(os.path.basename(face_img_path))[0] + ".jpg"), face_img_slice)

    # show image for testing
    # cv2.imshow(winname="final_image", mat=face_img_slice)
    # cv2.waitKey(0)
    # cv2.destroyAllWindows()


def uncover_nose(dst_face_point):
    dst_face_point[0][1] = dst_face_point[13][1]
    dst_face_point[10][1] = dst_face_point[18][1]

    dst_face_point[11][0] = (dst_face_point[24][0] + dst_face_point[12][0]) / 2
    dst_face_point[11][1] = (dst_face_point[24][1] + dst_face_point[12][1]) / 2

    return dst_face_point


def uncover_both(dst_face_point):
    dst_face_point[0] = dst_face_point[2]
    dst_face_point[10] = dst_face_point[8]

    dst_face_point[1][0] = (dst_face_point[2][0] + dst_face_point[3][0]) / 2
    dst_face_point[1][1] = (dst_face_point[2][1] + dst_face_point[3][1]) / 2

    dst_face_point[9][0] = (dst_face_point[8][0] + dst_face_point[7][0]) / 2
    dst_face_point[9][1] = (dst_face_point[8][1] + dst_face_point[7][1]) / 2

    dst_face_point[2] = dst_face_point[3]
    dst_face_point[8] = dst_face_point[7]

    dst_face_point[3][0] = (dst_face_point[3][0] + dst_face_point[4][0]) / 2
    dst_face_point[3][1] = (dst_face_point[3][1] + dst_face_point[4][1]) / 2

    dst_face_point[7][0] = (dst_face_point[7][0] + dst_face_point[6][0]) / 2
    dst_face_point[7][1] = (dst_face_point[7][1] + dst_face_point[6][1]) / 2

    dst_face_point[11] = dst_face_point[21]

    return dst_face_point


for i, face in enumerate(unmasked_faces):
    mask_path = os.path.join(arg['maskfolder'], masks[i % len(masks)])
    face_path = os.path.join(arg['facefolder'], face)
    print("==========================")
    print((len(unmasked_faces) - i), " images left")
    if image_handle(mask_path, face_path, arg['PATTERN']) == 0:
        continue
